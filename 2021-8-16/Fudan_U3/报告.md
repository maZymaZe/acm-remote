# 2021 牛客暑期多校训练营 10

杜雨轩 阮毅凡 吴可非

### 时间

2021-08-16 12:00:00

### 当场过的题

F H

### 补题

A C D I

### 题意+题解

#### A

题意：给若干字符串，求字符串集的最小大小是所以以集合中的字符串为前缀的都在前 i 位，前 i 个字符串都以集合中某一个字符串为前缀。

题解：如果空间限制宽的话可以，我们考虑 trie 树，在树上选尽量少的点，使这些点为前 i 个的祖先且不是后面的字符串的祖先，那么我们可以由前 i 个字符串的底部开始往上推，只要不成为后面的字符串的祖先就行。限制了空间，我们就应该只保留字符串之间“变线“的关键点，先对字符串排序，然后按照检查某一位是否相同进行递归建树，直到单点为止。答案的计数用差分数组

#### C

题意：n 对男女，每位女士都有对若干男士不感兴趣，问是否有一个完美匹配。

题解：先选出相当不受欢迎的男士(数量不多)，再筛选出对他们感兴趣的女士，跑匈牙利算法匹配。然后再处理剩余的男士与女士，用 set 暴力找就是了。

#### D

题意：求所有 n 个节点的带标号无根树的直径之和。

题解：考虑求树的直径的方法，每次去掉所有叶子节点直到只剩 1 或 2 个点，然后直径为操作次数\*2+余下点数。现在反过来在核心加叶子。

令 f[i\][j\]表示有 j 个叶子的 i 标号树的个数。

当我们想执行一轮添加新叶子操作时, 我们枚举添加 k 个新叶子, 这样 f[i][j] 就能
转移到 f[i + k\][k\].
有这样一个子问题:我们需要构建一个长度为 k 的子序列(这里的物理意义是将新叶子的父亲节点按新叶子编号写下来得到的序列, 该序列与加叶子方案一一对应), 其中序列中元素的取值有 i 种可能, 但有 j 种取值必须出现(要保证 j 个旧叶子必须被至少一个新叶子连接). 记这个的方案数为 g[i\][j\][k\].

有了 g 我们可以方便地计算 f: f[i + k\][k\]+ = f[i\][j\] · g[i\][j\][k] · C(i + k, i). 最后的
C(i + k, i) 指的是从 i + k 里面选出 i 个节点构成原本的 i 标号树.
现在问题变成了怎么计算 g[i\][j\][k\]. g[i\][j\][k\] 的计算我们可以用序列 dp 的想法.
考虑序列中第 k 个元素. 分类讨论一下.

1. 如果这个元素不是全新的特殊值(特殊值就是必须出现一次的值), 意思是这个元素要么是出现过的特殊值, 要么就不是特殊值, 那么去掉这个元素我们能得到一个类似的子问题结构. 所以这种情况下方案数是 i · g[i\][j\][k − 1\].
2. 如果这个元素是全新的特殊值, 意思是在之前已经出现过 j − 1 个特殊值, 这也
   变成了一个子问题. 所以这种情况下方案数是 j · g[i − 1\][j − 1\][k − 1\].
   两种情况合并一下就是 g[i\][j\][k\].

引入一个量 h[i\][j\], 表示有 j 个叶子的 i 标号树的直径和.同样的我们枚举新加 k 个叶子, 考虑 h[i\][j\] 对 h[i + k\][k\] 的贡献. 他的贡献其实分两部分.

1. 旧树直径的贡献: 一棵有 j 个叶子的 i 标号树在添加 k 个新叶子之后, 会衍生出
   g[i\][j\][k\] 棵新树, 意味着它的旧树直径贡献会被放大 g[i\][j\][k\] 倍. 所以这部分的计算是 h[i + k\][k\]+ = h[i\][j\] · g[i\][j\][k\].
2. 新叶贡献: 由于新叶的贡献是固定的 2, 所以有多少种新树, 就有相应数量的新叶贡献. 这部分的计算是 h[i + k\][k\]+ = 2f[i + k\][k\].

得到 h 之后求和 h[n\][i\]就能获得最终答案了.

#### F

题意：给一括号序列代表进出栈的次序，和一些要进出栈的数，问是否有方案能使进栈操作后的栈两两不相同。

题解：可以发现，冲突会在类似(()())中第 2,3 次的情形中出现，可以预处理出要互异的各元组，然后安排数，优先安排频次高的，用 set 维护频数。如果元组大小大于 set 的大小则不能完成。

#### H

题意：要求给一个 $n$ 维的超立方体的顶点黑白染色，满足每个点相邻同色点个数小于 $\left \lceil \sqrt{n}\right \rceil$

题解：黑白相间染色即可

#### I

题意：$H$ 的加强版，要求黑点数和白点数不同

题解：先将每一个二进制编号后面补零直到长度变为 $\left \lceil \sqrt{n}\right \rceil ^2$ ，然后把每一个编号转化成 $\left \lceil \sqrt{n}\right \rceil*\left \lceil \sqrt{n}\right \rceil$ 的矩阵，将所有编号分为四类：

- $1$ 的个数为奇数，前 $\left \lceil \frac{n}{\left \lceil \sqrt{n}\right \rceil} \right \rceil$行中不存在一行全为 $0$，数量记为 $A$

- $1$ 的个数为奇数，前 $\left \lceil \frac{n}{\left \lceil \sqrt{n}\right \rceil} \right \rceil$行中存在一行全为 $0$，数量记为 $B$

- $1$ 的个数为偶数，前 $\left \lceil \frac{n}{\left \lceil \sqrt{n}\right \rceil} \right \rceil$行中不存在一行全为 $0$，数量记为 $C$

- $1$ 的个数为偶数，前 $\left \lceil \frac{n}{\left \lceil \sqrt{n}\right \rceil} \right \rceil$行中存在一行全为 $0$，数量记为 $D$

第一种和第四种染黑，第二种和第三种染白即可满足要求，原因如下：
$A+B=C+D=2^{n-1},A+C\equiv 1(mod 2)$

### 训练总结

杜雨轩：感觉还是有些可做题没做出来，可惜。
吴可非：$I$ 题的构造确实精妙，此外就是字符串的题需要加强
阮毅凡：有些题目还是可做的，差了一点
